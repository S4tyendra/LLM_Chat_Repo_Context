Folder structure:
├── tmpqu97eipl/
├── pandrator.ico
├── pandrator.png
├── pandrator.py
├── pandrator_demonstration.gif
├── pandrator_installer_launcher.py
├── README.md
├── requirements.txt
├── tts_voices/
│   ├── sample_male_new.wav
│   ├── VoiceCraft/
│   │   ├── sample_male_16k.txt
│   │   ├── sample_male_16k.wav
│   │   ├── tmp.txt

Concatenated content:

---/---


--README.md--

<p align="left">
  <img src="pandrator.png" alt="Icon" width="200" height="200"/>
</p>

# Pandrator, a GUI audiobook and dubbing generator with voice cloning and AI text optimisation
>[!NOTE]
> Please note that Pandrator is still in an alpha stage and I'm not an experienced developer (I'm a noob, in fact), so the code is far from perfect in terms of optimisation, features and reliability. Please keep this in mind and contribute, if you want to help me make it better.

Pandrator aspires to be easy to use and install - it has a one-click installer and a graphical user interface. It is a tool designed to perform two tasks: 
- transform text, PDF, EPUB and SRT files into spoken audio in multiple languages based on open source software, including preprocessing to make the generated speech sound as natural as possible by, among other things, splitting the text into paragraphs, sentences and smaller logical text blocks (clauses), which the TTS models can process with minimal artifacts. Each sentence can be regenerated if the first attempt is not satisfacory. Voice cloning is possible for models that support it, and text can be additionally preprocessed using LLMs (to remove OCR artifacts or spell out things that the TTS models struggle with, like Roman numerals and abbreviations, for example),
- generate dubbing either directly from a video file, including transcription (using [WhisperX](https://github.com/m-bain/whisperX)), or from an .srt file. It includes a complete workflow from a video file to a dubbed video file with subtitles - including translation using a variety of APIs and techniques to improve the quality of translation. [Subdud](https://github.com/lukaszliniewicz/Subdub), a companion app developed for this purpose, can also be used on its own.  

It leverages the [XTTS](https://huggingface.co/coqui/XTTS-v2), [Silero](https://github.com/snakers4/silero-models) and [VoiceCraft](https://github.com/jasonppy/VoiceCraft) model(s) for text-to-speech conversion and voice cloning, enhanced by [RVC_CLI](https://github.com/blaisewf/rvc-cli) for quality improvement and better voice cloning results, and NISQA for audio quality evaluation. Additionally, it incorporates [Text Generation Webui's](https://github.com/oobabooga/text-generation-webui) API for local LLM-based text pre-processing, enabling a wide range of text manipulations before audio generation.

- [Pandrator, an audiobook generator](#pandrator-an-audiobook-generator)
  - [Samples](#samples)
  - [Requirements](#requirements)
    - [Hardware](#hardware)
    - [Dependencies](#dependencies)
      - [Required](#required)
      - [Optional](#optional)
  - [Installation](#installation)
    - [Minimal One-Click Installation Executable (Windows with an Nvidia GPU only)](#installer-and-launcher)
    - [Manual Installation](#manual-installation)
  - [Features](#features)
  - [Quick Start Guide](#quick-start-guide)
    - [Basic Usage](#basic-usage)
    - [General Audio Settings](#general-audio-settings)
    - [General Text Pre-Processing Settings](#general-text-pre-processing-settings)
    - [LLM Pre-processing](#llm-preprocessing)
    - [RVC Quality Enhancement and Voice Cloning](#rvc-quality-enhancement-and-voice-cloning)
    - [NISQA TTS Evaluation](#nisqa-tts-evaluation)
  - [Contributing](#contributing)
  - [Tips](#tips)
  - [To-do](#to-do)

![UI Demonstration Image](pandrator_demonstration.gif)

## Samples
The samples were generated using the minimal settings - no LLM text processing, RVC or TTS evaluation, and no sentences were regenerated. Both XTTS and Silero generations were faster than playback speed. 

https://github.com/user-attachments/assets/1c763c94-c66b-4c22-a698-6c4bcf3e875d

https://github.com/lukaszliniewicz/Pandrator/assets/75737665/bbb10512-79ed-43ea-bee3-e271b605580e

https://github.com/lukaszliniewicz/Pandrator/assets/75737665/118f5b9c-641b-4edd-8ef6-178dd924a883

Dubbing sample, including translation ([video source](https://www.youtube.com/watch?v=_SwUpU0E2Eg&t=61s&pp=ygUn0LLRi9GB0YLRg9C_0LvQtdC90LjQtSDQu9C10LPQsNGB0L7QstCw)):

https://github.com/user-attachments/assets/1ba8068d-986e-4dec-a162-3b7cc49052f4

## Requirements

### Hardware
#### XTTS
It's likely that you will need at least 16GB of RAM, a reasonably modern CPU for CPU-only generation (which you can choose in the launcher), and ideally an NVIDIA GPU with 4 GB+ of VRAM for really good performance.
#### Silero
Silero runs on the CPU. It should perform well on almost all reasonably modern systems. 
#### VoiceCraft
You can run VoiceCraft on a cpu, but generation will be very slow. To achieve meaningful acceleration with a GPU (Nvidia), you need one with at least 8GB of VRAM. If you have only 4GB, disable kv cache in advanced settings. 

### Dependencies
This project relies on several APIs and services (running locally) and libraries, notably:

#### Required
- [XTTS API Server by daswer123](https://github.com/daswer123/xtts-api-server.git) for Text-to-Speech (TTS) generation using Coqui [XTTSv2](https://huggingface.co/coqui/XTTS-v2) OR [Silero API Server by ouoertheo](https://github.com/ouoertheo/silero-api-server) for TTS generaton using the [Silero models](https://github.com/snakers4/silero-models) OR [VoiceCraft by jasonppy](https://github.com/jasonppy/VoiceCraft). XTTS and VoiceCraft perform best on a GPU (Nvidia), though can work on a CPU (especially XTTS), and Silero uses only the CPU. Silero can be run on low-end systems.
- [FFmpeg](https://github.com/FFmpeg/FFmpeg) for audio encoding.
- [Sentence Splitter by mediacloud](https://github.com/mediacloud/sentence-splitter) for splitting `.txt ` files into sentences, [customtkinter by TomSchimansky](https://github.com/TomSchimansky/CustomTkinter), [num2words by savoirfairelinux](https://github.com/savoirfairelinux/num2words) for converting numbers to words (Silero requirs this), `pysrt`, `pydub` and others (see `requirements.txt`). 

#### Optional
- [Text Generation Webui API by oobabooga](https://github.com/oobabooga/text-generation-webui.git) for LLM-based text pre-processing.
- [RVC_CLI by blaise-tk](https://github.com/blaise-tk/RVC_CLI.git) for enhancing voice quality and cloning results with [Retrieval Based Voice Conversion](https://github.com/RVC-Project/Retrieval-based-Voice-Conversion-WebUI).
- [NISQA by gabrielmittag](https://github.com/gabrielmittag/NISQA.git) for evaluating TTS generations (using the [FastAPI implementation](https://github.com/lukaszliniewicz/NISQA-API)).

## Installation

### GUI Installer and Launcher (Windows)
Run `pandrator_installer_launcher.exe` with administrator priviliges. You will find it under [Releases](https://github.com/lukaszliniewicz/Pandrator/releases). The executable was created using [pyinstaller](https://github.com/pyinstaller/pyinstaller) from `pandrator_installer_launcher.py` in the repository.

**The file may be flagged as a threat by antivirus software, so you may have to add it as an exception.**

You can choose which TTS engines to install and whether to install the software that enabled RVC voice cloning (RVC_CLI). You may install new components later. The installer creates the Pandrator folder, installs `winget`, `git`, `ffmpeg`, `C++ Build Tools` and/or `Calibre` if not installed already and `Miniconda`, clones the XTTS Api Server respository, the Silero Api Server repository or the VoiceCraft API repository and the Pandrator repository, creates conda environments, installs dependencies and launches Pandrator and the server you chose. **You may use the the Installer/Launcher to launch Pandrator and all the tools later**. 

If you want to perform the setup again, remove the Pandrator folder it created. Please allow at least a couple of minutes for the initial setup process to download models and install dependencies. Depending on the options you've chosen, it may take up to 25 minutes.

For additional functionality not yet included in the installer:
- Install Text Generation Webui and remember to enable the API (add `--api` to `CMD_FLAGS.txt` in the main directory of the Webui before starting it).
- Set up NISQA API for automatic evaluation of generations.

Please refer to the repositories linked under [Dependencies](#Dependencies) for detailed installation instructions. Remember that the APIs must be running to make use of the functionalities they offer.

### Manual Installation:
1. Make sure that Python 3, git, calibre and ffmpeg are installed and in PATH.
2. Install and run at least XTTS API Server, Silero API Server or VoiceCraft API Server. 
3. Clone this repository (`git clone https://github.com/lukaszliniewicz/Pandrator.git`).
4. `cd` to the repository directory.
5. Install requirements using `pip install -r requirements.txt`.
6. Run `python pandrator.py`.

## Features
- **Text Pre-processing:** Splits text into sentences and (attempts to) preserve paragraphs. Profiles for multiple languages are available.
- **LLM Text Pre-processing:** Utilizes a local LLM for text corrections and enhancements with up to three different prompts run sequentially, and an evaluation mechanism that asks the model to perform a task twice and then choose the better response. I've been using `openchat-3.5-0106.Q5_K_M.gguf` with good results, as well as for example `Mistral 7B Instruct 0.2`. Different models may perform different tasks well, so it's possible to choose a specific model for a specific prompt.
- **Audio Generation:** Converts processed text into speech, with options for voice cloning and quality enhancement. It currently supports `.txt`,  `.srt` and `.pdf` files. 
- **Audio Evaluation:** An experimental feature that predicts Mean Opinion Score (MOS) for generated sentences and sets a score threshold or chooses the best score from a set number of generations.
- **Generating and adding dubbing to video files:** Speech generated from subtitle files is synchronized with the SRT timestamps and can be saved as a file or mixed with an audio track of a video file, effectively producing dubbing. It handles cases where generated speech exceeds the time alloted for a subtitle and self-corrects synchronisation. It's possible to speed up or slow down generated audio. 
- **Session Management:** Supports creating, deleting, and loading sessions for organized workflow.
- **GUI:** Built with customtkinker for a user-friendly experience.

## Quick Start Guide
### Basic Usage
If you don't want to use the additional functionalities, you have everything you need in the **Session tab**. 

1. Either create a new session or load an existing one (select a folder in `Outputs` to do that).
2. Choose your `.txt`, `.srt`, `.pdf` or `epub` file. If you choose a PDF or EPUB file, a preview window will open with the extracted text. You may edit it (OCRed books often have poorly recognized text from the title page, for example). Files that contain a lot of text, regardless of format, can take a long time to finish preprocessing before generation begins. The GUI will freeze, but as long as there is processor activity, it's simply working. For whole books, expect 10m+ for preprocessing.
3. Select the TTS server you want to use - XTTS, Silero or VoiceCraft - and the language from the dropdown (VoiceCraft currently supports only English).
4. Choose the voice you want to use.
   1. **XTTS**, voices are short, 6-12s `.wav` files (22050hz sample rate, mono) stored in the `tts_voices` directory. The XTTS model uses the audio to clone the voice. It doesn't matter what language the sample is in, you will be able to generate speech in all supported languages, but the quality will be best if you provide a sample in your target language. You may use the sample one in the repository or upload your own. Please make sure that the audio is between 6 and 12s, mono, and the sample rate is 22050hz. You may use a tool like Audacity to prepare the files. The less noise, the better. You may use a tool like [Resemble AI](https://github.com/resemble-ai/resemble-enhance) for denoising and/or enhancement of your samples on [Hugging Face](https://huggingface.co/spaces/ResembleAI/resemble-enhance).
   2. **Silero** offers a number of voices for each language it supports. It doesn't support voice cloning. Simply select a voice from the dropdown after choosing the language.
   3. **VoiceCraft** works similarly to XTTS in that it clones the voice from a `.wav ` sample. However, it needs both a properly formatted `.wav` file (mono, 16000hz) and a `.txt` file with the transcription of what is said in the sample. The files must have the same name (apart from the extension, of course). You need to upload them to `tts_voices/VoiceCraft` and you will be able to select them in the GUI. Currently only English is supported. If you generate with a new voice for the first time, the server will perform the alignment procedure, so the first sentence will be generated with a delay. This won't happen when you use that voice again.
6. If you want, you can either slow down or speed up the generated audio (type in or choose a ratio, e.g. 1.1, which is 10% faster than generated; it may be especially useful for dubbing).
7. If you chose an `.srt` file, you will be given the option to select a video file and one of its audio tracks to mix with the synchronized output, as well as weather you want to lower the volume of the original audio when subtitle audio is playing.
8. Start the generation. You may stop and resume it later, or close the programme and load the session later.
9. You can play back the generated sentences, also as a playlist, edit them (the text for regeneration), regenerate or remove individual ones.
10. "Save Output" concatenates the sentences generated so far an encodes them as one file (default is `.opus` at 64k bitrate; you may change it in the Audio tab to `.wav` or `.mp3`).

### General Audio Settings
1. You can change the lenght of silence appended to the end of sentences and paragraphs.
2. You can enable a fade-in and -out effect and set the duration.
3. You can choose the output format and bitrate.

### General Text Pre-Processing Settings
1. You can disable/enable splitting long sentences and set the max lenght a text fragment sent for TTS generation may have (enabled by default; it tries to split sentences whose lenght exceeds the max lenght value; it looks for punctuation marks (, ; : -) and chooses the one closest to the midpoint of the sentence; if there are no punctuation marks, it looks for conjunctions like "and"); it performs this operation twice as some sentence fragments may still be too long after just one split.
2. You can disable/enable appending short sentences (to preceding or following sentences; disabled by default, may perhaps improve the flow as the lenght of text fragments sent to the model is more uniform).
3. Remove diacritics (useful when generating a text that contains many foreign words or transliterations from foreign alphabets, e.g. Japanese). Do not enable this if you generate in a language that needs diacritics, like German or Polish! The pronounciation will be wrong then.

### LLM Pre-processing
- Enable LLM processing to use language models for preprocessing the text before sending it to the TTS API. For example, you may ask the LLM to remove OCR artifacts, spell out abbreviations, correct punctuation etc.
- You can define up to three prompts for text optimization. Each prompt is sent to the LLM API separately, and the output of the last prompt is used for TTS generation.
- For each prompt, you can enable/disable it, set the prompt text, choose the LLM model to use, and enable/disable evaluation (if enabled, the LLM API will be called twice for each prompt, and then again for the model to choose the better result).
- Load the available LLM models using the "Load LLM Models" button in the Session tab.

### RVC Quality Enhancement and Voice Cloning
- Enable RVC to enhance the generated audio quality and apply voice cloning.
- Select the RVC model file (.pth) and the corresponding index file using the "Select RVC Model" and "Select RVC Index" buttons in the Audio Processing tab.
- When RVC is enabled, the generated audio will be processed using the selected RVC model and index before being saved.

### NISQA TTS Evaluation
- Enable TTS evaluation to assess the quality of the generated audio using the NISQA (Non-Intrusive Speech Quality Assessment) model.
- Set the target MOS (Mean Opinion Score) value and the maximum number of attempts for each sentence.
- When TTS evaluation is enabled, the generated audio will be evaluated using the NISQA model, and the best audio (based on the MOS score) will be chosen for each sentence.
- If the target MOS value is not reached within the maximum number of attempts, the best audio generated so far will be used.

## Contributing
Contributions, suggestions for improvements, and bug reports are most welcome!

## Tips
- You can find a collection of voice sample for example [here](https://aiartes.com/voiceai). They are intended for use with ElevenLabs, so you will need to pick an 8-12s fragment and save it as 22050khz mono `.wav` usuing Audacity, for instance.
- You can find a collection of RVC models for example [here](https://voice-models.com/).

## To-do
- [ ] Add support for chapter segmentation
- [ ] Add support for Surya for PDF OCR, layout and redeaing order detection, plus preprocessing of chapters, headers, footers, footnotes and tables. 
- [ ] Add support for StyleTTS2
- [ ] Add importing/exporting settings.
- [ ] Add support for proprietary APIs for text pre-processing and TTS generation.
- [ ] Include OCR for PDFs.
- [ ] Add support for a higher quality local TTS model, Tortoise.
- [ ] Add option to record a voice sample and use it for TTS to the GUI.
- [x] Add all API servers to the setup script.
- [x] Add support for custom XTTS models 
- [x] Add workflow to create dubbing from `.srt` subtitle files.
- [x] Include support for PDF files.
- [x] Integrate editing capabilities for processed sentences within the UI.
- [x] Add support for a lower quality but faster local TTS model that can easily run on CPU, e.g. Silero or Piper.
- [x] Add support for EPUB.




--pandrator_installer_launcher.py--

import os
import subprocess
import logging
import time
import shutil
import requests
import threading
import customtkinter as ctk
from datetime import datetime
import atexit
import psutil
import json
import tkinter.messagebox as messagebox
import traceback
import tempfile
import sys
import ctypes
import winreg
from dulwich import porcelain
import packaging.version

class ScrollableFrame(ctk.CTkScrollableFrame):
    def __init__(self, container, *args, **kwargs):
        super().__init__(container, *args, **kwargs)
        self.inner_frame = ctk.CTkFrame(self, fg_color="transparent")
        self.inner_frame.pack(fill="both", expand=True)

    def get_inner_frame(self):
        return self.inner_frame

class PandratorInstaller(ctk.CTk):
    def __init__(self):
        super().__init__()
        self.initial_working_dir = os.getcwd()
        # Define instance variables for checkboxes
        self.pandrator_var = ctk.BooleanVar(value=True)
        self.xtts_var = ctk.BooleanVar(value=False)
        self.xtts_cpu_var = ctk.BooleanVar(value=False)
        self.silero_var = ctk.BooleanVar(value=False)
        self.voicecraft_var = ctk.BooleanVar(value=False)
        self.rvc_var = ctk.BooleanVar(value=False)

        # Define instance variables for launch options
        self.launch_pandrator_var = ctk.BooleanVar(value=True)
        self.launch_xtts_var = ctk.BooleanVar(value=False)
        self.lowvram_var = ctk.BooleanVar(value=False)
        self.deepspeed_var = ctk.BooleanVar(value=False)
        self.xtts_cpu_launch_var = ctk.BooleanVar(value=False)
        self.launch_silero_var = ctk.BooleanVar(value=False)
        self.launch_voicecraft_var = ctk.BooleanVar(value=False)

        # Initialize process attributes
        self.xtts_process = None
        self.pandrator_process = None
        self.silero_process = None
        self.voicecraft_process = None

        self.title("Pandrator Installer & Launcher")
        
        # Calculate 92% of screen height and get full screen width
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        window_height = int(screen_height * 0.92)

        # Set the window geometry to full width and 92% height, positioned at the top
        self.geometry(f"{screen_width}x{window_height}+0+0")

        ctk.set_appearance_mode("dark")
        ctk.set_default_color_theme("blue")

        # Create main scrollable frame
        self.main_frame = ScrollableFrame(self)
        self.main_frame.pack(fill="both", expand=True, padx=10, pady=10)

        # Content Frame (to align content to the top)
        self.content_frame = ctk.CTkFrame(self.main_frame.get_inner_frame(), fg_color="transparent")
        self.content_frame.pack(fill="both", expand=True)

        # Title
        self.title_label = ctk.CTkLabel(self.content_frame, text="Pandrator Installer & Launcher", font=("Arial", 32, "bold"))
        self.title_label.pack(pady=(20, 10))

        # Information Text Area
        self.info_text = ctk.CTkTextbox(self.content_frame, height=100, wrap="word", font=("Arial", 12))
        self.info_text.pack(fill="x", padx=20, pady=10)
        self.info_text.insert("1.0", "This tool will help you set up and run Pandrator as well as TTS engines and tools. "
                              "It will install Pandrator, Miniconda, required Python packages, "
                              "and dependencies (Calibre, Visual Studio C++ Build Tools) using winget if not installed already.\n\n"
                              "To uninstall Pandrator, simply delete the Pandrator folder.\n\n"
                              "The installation will take about 6-20GB of disk space depending on the number of selected options.")
        self.info_text.configure(state="disabled")

        # Installation Frame
        self.installation_frame = ctk.CTkFrame(self.content_frame)
        self.installation_frame.pack(fill="x", padx=20, pady=10)

        ctk.CTkLabel(self.installation_frame, text="Installation", font=("Arial", 18, "bold")).pack(anchor="w", padx=10, pady=(10, 5))

        self.pandrator_checkbox = ctk.CTkCheckBox(self.installation_frame, text="Pandrator", variable=self.pandrator_var)
        self.pandrator_checkbox.pack(anchor="w", padx=10, pady=(5, 0))

        ctk.CTkLabel(self.installation_frame, text="TTS Engines", font=("Arial", 14, "bold")).pack(anchor="w", padx=10, pady=(20, 0))
        ctk.CTkLabel(self.installation_frame, text="You can select and install new engines and tools after the initial installation.", font=("Arial", 10, "bold")).pack(anchor="w", padx=10, pady=(0, 10))

        engine_frame = ctk.CTkFrame(self.installation_frame)
        engine_frame.pack(fill="x", padx=10, pady=(0, 10))
        
        self.xtts_checkbox = ctk.CTkCheckBox(engine_frame, text="XTTS", variable=self.xtts_var)
        self.xtts_checkbox.pack(side="left", padx=(0, 20), pady=5)
        self.xtts_cpu_checkbox = ctk.CTkCheckBox(engine_frame, text="XTTS CPU only", variable=self.xtts_cpu_var)
        self.xtts_cpu_checkbox.pack(side="left", padx=(0, 20), pady=5)

        self.silero_checkbox = ctk.CTkCheckBox(engine_frame, text="Silero", variable=self.silero_var)
        self.silero_checkbox.pack(side="left", padx=(0, 20), pady=5)
        self.voicecraft_checkbox = ctk.CTkCheckBox(engine_frame, text="Voicecraft", variable=self.voicecraft_var)
        self.voicecraft_checkbox.pack(side="left", padx=(0, 20), pady=5)

        ctk.CTkLabel(self.installation_frame, text="Other tools", font=("Arial", 14, "bold")).pack(anchor="w", padx=10, pady=(20, 5))

        self.rvc_checkbox = ctk.CTkCheckBox(self.installation_frame, text="RVC (rvc-python)", variable=self.rvc_var)
        self.rvc_checkbox.pack(anchor="w", padx=10, pady=5)
        self.whisperx_var = ctk.BooleanVar(value=False)
        self.whisperx_checkbox = ctk.CTkCheckBox(self.installation_frame, text="WhisperX", variable=self.whisperx_var)
        self.whisperx_checkbox.pack(anchor="w", padx=10, pady=5)

        button_frame = ctk.CTkFrame(self.installation_frame)
        button_frame.pack(anchor="w", padx=10, pady=(20, 10))

        self.install_button = ctk.CTkButton(button_frame, text="Install", command=self.install_pandrator, width=200, height=40)
        self.install_button.pack(side="left", padx=(0, 10))
        self.update_button = ctk.CTkButton(button_frame, text="Update Pandrator", command=self.update_pandrator, width=200, height=40)
        self.update_button.pack(side="left", padx=10)
        self.open_log_button = ctk.CTkButton(button_frame, text="View Installation Log", command=self.open_log_file, width=200, height=40)
        self.open_log_button.pack(side="left", padx=10)
        self.open_log_button.configure(state="disabled")

        # Launch Frame
        self.launch_frame = ctk.CTkFrame(self.content_frame)
        self.launch_frame.pack(fill="x", padx=20, pady=10)
        ctk.CTkLabel(self.launch_frame, text="Launch", font=("Arial", 18, "bold")).grid(row=0, column=0, columnspan=4, sticky="w", padx=10, pady=(10, 5))
        ctk.CTkCheckBox(self.launch_frame, text="Pandrator", variable=self.launch_pandrator_var).grid(row=1, column=0, columnspan=4, sticky="w", padx=10, pady=5)

        # XTTS options in one row
        ctk.CTkCheckBox(self.launch_frame, text="XTTS", variable=self.launch_xtts_var).grid(row=2, column=0, sticky="w", padx=10, pady=5)
        self.xtts_cpu_checkbox = ctk.CTkCheckBox(self.launch_frame, text="Use CPU", variable=self.xtts_cpu_launch_var)
        self.xtts_cpu_checkbox.grid(row=2, column=1, sticky="w", padx=10, pady=5)
        self.lowvram_checkbox = ctk.CTkCheckBox(self.launch_frame, text="Low VRAM", variable=self.lowvram_var)
        self.lowvram_checkbox.grid(row=2, column=2, sticky="w", padx=10, pady=5)
        self.deepspeed_checkbox = ctk.CTkCheckBox(self.launch_frame, text="DeepSpeed", variable=self.deepspeed_var)
        self.deepspeed_checkbox.grid(row=2, column=3, sticky="w", padx=10, pady=5)

        ctk.CTkCheckBox(self.launch_frame, text="Silero", variable=self.launch_silero_var).grid(row=3, column=0, columnspan=4, sticky="w", padx=10, pady=5)
        ctk.CTkCheckBox(self.launch_frame, text="Voicecraft", variable=self.launch_voicecraft_var).grid(row=4, column=0, columnspan=4, sticky="w", padx=10, pady=5)
        self.launch_button = ctk.CTkButton(self.launch_frame, text="Launch", command=self.launch_apps, width=200, height=40)
        self.launch_button.grid(row=5, column=0, columnspan=4, sticky="w", padx=10, pady=(20, 10))

        # Progress Bar and Status Label
        self.progress_bar = ctk.CTkProgressBar(self.content_frame)
        self.progress_bar.pack(fill="x", padx=20, pady=(20, 10))
        self.progress_bar.set(0)

        self.status_label = ctk.CTkLabel(self.content_frame, text="", font=("Arial", 14))
        self.status_label.pack(pady=(0, 10))
        self.refresh_ui_state()
        atexit.register(self.shutdown_apps)

    def initialize_logging(self):
        pandrator_path = os.path.join(self.initial_working_dir, 'Pandrator')
        os.makedirs(pandrator_path, exist_ok=True)
        logs_path = os.path.join(pandrator_path, 'Logs')
        os.makedirs(logs_path, exist_ok=True)

        current_time = datetime.now().strftime("%Y%m%d_%H%M%S")
        self.log_filename = os.path.join(logs_path, f'pandrator_installation_log_{current_time}.log')
        logging.basicConfig(filename=self.log_filename, level=logging.DEBUG,
                            format='%(asctime)s - %(levelname)s - %(message)s')

        self.open_log_button.configure(state="normal")

    def disable_buttons(self):
        for widget in self.installation_frame.winfo_children():
            if isinstance(widget, (ctk.CTkCheckBox, ctk.CTkButton)):
                widget.configure(state="disabled")
        self.launch_button.configure(state="disabled")

    def enable_buttons(self):
        self.refresh_ui_state()

    def refresh_ui_state(self):
        pandrator_path = os.path.join(self.initial_working_dir, 'Pandrator')
        config_path = os.path.join(pandrator_path, 'config.json')
        
        if os.path.exists(config_path):
            with open(config_path, 'r') as f:
                config = json.load(f)
        else:
            config = {}

        # Helper function
        def set_widget_state(widget, state, value=None):
            widget.configure(state=state)
            if isinstance(widget, ctk.CTkCheckBox) and value is not None:
                if value:
                    widget.select()
                else:
                    widget.deselect()

        # Pandrator
        pandrator_installed = os.path.exists(pandrator_path)
        set_widget_state(self.pandrator_checkbox, "disabled" if pandrator_installed else "normal", False)
        set_widget_state(self.launch_frame.winfo_children()[1], "normal" if pandrator_installed else "disabled", pandrator_installed)

        # XTTS
        xtts_support = config.get('xtts_support', False)
        xtts_cuda_support = config.get('cuda_support', False)
        
        # Disable both XTTS and XTTS CPU checkboxes if XTTS is installed in any form
        set_widget_state(self.xtts_checkbox, "disabled" if xtts_support else "normal", False)
        set_widget_state(self.xtts_cpu_checkbox, "disabled" if xtts_support else "normal", False)
        
        xtts_launch_checkbox = next(widget for widget in self.launch_frame.winfo_children() if isinstance(widget, ctk.CTkCheckBox) and widget.cget("text") == "XTTS")
        set_widget_state(xtts_launch_checkbox, "normal" if xtts_support else "disabled", False)
        
        cpu_checkbox = next(widget for widget in self.launch_frame.winfo_children() if isinstance(widget, ctk.CTkCheckBox) and widget.cget("text") == "Use CPU")
        lowvram_checkbox = next(widget for widget in self.launch_frame.winfo_children() if isinstance(widget, ctk.CTkCheckBox) and widget.cget("text") == "Low VRAM")
        deepspeed_checkbox = next(widget for widget in self.launch_frame.winfo_children() if isinstance(widget, ctk.CTkCheckBox) and widget.cget("text") == "DeepSpeed")
        
        if xtts_support:
            if xtts_cuda_support:
                set_widget_state(cpu_checkbox, "normal", False)
                set_widget_state(lowvram_checkbox, "normal", False)
                set_widget_state(deepspeed_checkbox, "normal", True)
            else:
                set_widget_state(cpu_checkbox, "normal", True)
                set_widget_state(lowvram_checkbox, "disabled", False)
                set_widget_state(deepspeed_checkbox, "disabled", False)
        else:
            set_widget_state(cpu_checkbox, "disabled", False)
            set_widget_state(lowvram_checkbox, "disabled", False)
            set_widget_state(deepspeed_checkbox, "disabled", False)
        
        if xtts_support:
            if xtts_cuda_support:
                set_widget_state(cpu_checkbox, "normal", False)
                set_widget_state(lowvram_checkbox, "normal", False)
                set_widget_state(deepspeed_checkbox, "normal", True)
            else:
                set_widget_state(cpu_checkbox, "normal", True)
                set_widget_state(lowvram_checkbox, "disabled", False)
                set_widget_state(deepspeed_checkbox, "disabled", False)
        else:
            set_widget_state(cpu_checkbox, "disabled", False)
            set_widget_state(lowvram_checkbox, "disabled", False)
            set_widget_state(deepspeed_checkbox, "disabled", False)

        # Silero
        silero_support = config.get('silero_support', False)
        set_widget_state(self.silero_checkbox, "disabled" if silero_support else "normal", False)
        silero_launch_checkbox = next(widget for widget in self.launch_frame.winfo_children() if isinstance(widget, ctk.CTkCheckBox) and widget.cget("text") == "Silero")
        set_widget_state(silero_launch_checkbox, "normal" if silero_support else "disabled", False)

        # VoiceCraft
        voicecraft_support = config.get('voicecraft_support', False)
        set_widget_state(self.voicecraft_checkbox, "disabled" if voicecraft_support else "normal", False)
        voicecraft_launch_checkbox = next(widget for widget in self.launch_frame.winfo_children() if isinstance(widget, ctk.CTkCheckBox) and widget.cget("text") == "Voicecraft")
        set_widget_state(voicecraft_launch_checkbox, "normal" if voicecraft_support else "disabled", False)

        # RVC
        rvc_support = config.get('rvc_support', False)
        set_widget_state(self.rvc_checkbox, "disabled" if rvc_support else "normal", False)

        # WhisperX
        whisperx_support = config.get('whisperx_support', False)
        set_widget_state(self.whisperx_checkbox, "disabled" if whisperx_support else "normal", False)

        # Update launch and install buttons state
        self.launch_button.configure(state="normal" if pandrator_installed else "disabled")
        self.install_button.configure(state="normal")
        self.update_button.configure(state="normal" if pandrator_installed else "disabled")

    def get_installed_components(self):
        pandrator_path = os.path.join(self.initial_working_dir, 'Pandrator')
        config_path = os.path.join(pandrator_path, 'config.json')
        
        if os.path.exists(config_path):
            with open(config_path, 'r') as f:
                config = json.load(f)
        else:
            config = {}
        
        return {
            'xtts': config.get('xtts_support', False),
            'silero': config.get('silero_support', False),
            'voicecraft': config.get('voicecraft_support', False),
            'rvc': config.get('rvc_support', False),
            'whisperx': config.get('whisperx_support', False)
        }

    def install_whisperx(self, conda_path, env_name):
        logging.info(f"Installing WhisperX in {env_name}...")
        try:
            # Install Git through Conda
            self.run_command([
                os.path.join(conda_path, 'Scripts', 'conda.exe'),
                'install', '-n', env_name,
                'git', '-c', 'conda-forge', '-y'
            ])
            
            # Install PyTorch
            self.run_command([
                os.path.join(conda_path, 'Scripts', 'conda.exe'),
                'run', '-n', env_name,
                'pip', 'install',
                'torch==2.0.1', 'torchvision==0.15.2', 'torchaudio==2.0.2',
                '--index-url', 'https://download.pytorch.org/whl/cu118'
            ])
            
            # Install cuDNN
            self.run_command([
                os.path.join(conda_path, 'Scripts', 'conda.exe'),
                'install', '-n', env_name,
                'cudnn=8.9.7.29', '-c', 'conda-forge', '-y'
            ])
            
            # Install ffmpeg
            self.run_command([
                os.path.join(conda_path, 'Scripts', 'conda.exe'),
                'install', '-n', env_name,
                'ffmpeg', '-c', 'conda-forge', '-y'
            ])
            
            # Install WhisperX
            self.run_command([
                os.path.join(conda_path, 'Scripts', 'conda.exe'),
                'run', '-n', env_name,
                'pip', 'install', 'git+https://github.com/m-bain/whisperx.git'
            ])
            
            logging.info("WhisperX installation completed successfully.")
        except subprocess.CalledProcessError as e:
            logging.error(f"Failed to install WhisperX in {env_name}")
            logging.error(f"Error message: {str(e)}")
            raise

    def remove_directory(self, path):
        max_attempts = 5
        for attempt in range(max_attempts):
            try:
                shutil.rmtree(path)
                return True
            except PermissionError:
                time.sleep(1)  # Wait for a second before retrying
        return False
    
    def install_pandrator(self):
        pandrator_path = os.path.join(self.initial_working_dir, 'Pandrator')
        pandrator_already_installed = os.path.exists(pandrator_path)
        
        installed_components = self.get_installed_components()
        
        new_components_selected = (
            (self.xtts_var.get() or self.xtts_cpu_var.get()) and not installed_components['xtts'] or
            self.silero_var.get() and not installed_components['silero'] or
            self.voicecraft_var.get() and not installed_components['voicecraft'] or
            self.rvc_var.get() and not installed_components['rvc'] or
            self.whisperx_var.get() and not installed_components['whisperx']
        )
        
        if pandrator_already_installed and not self.pandrator_var.get():
            if not new_components_selected:
                messagebox.showinfo("Info", "No new components selected for installation.")
                return
        elif not pandrator_already_installed and not self.pandrator_var.get():
            messagebox.showerror("Error", "Pandrator must be installed first before adding new components.")
            return

        self.disable_buttons()
        self.progress_bar.set(0)
        self.status_label.configure(text="Installing...")

        self.initialize_logging()

        logging.info("Installation process started.")

        threading.Thread(target=self.install_process, daemon=True).start()

    def open_log_file(self):
        if hasattr(self, 'log_filename') and os.path.exists(self.log_filename):
            os.startfile(self.log_filename)
        else:
            self.status_label.configure(text="No log file available.")

    def update_progress(self, value):
        self.progress_bar.set(value)

    def update_status(self, text):
        self.status_label.configure(text=text)
        logging.info(text)

    def run_command(self, command, use_shell=False, cwd=None):
        try:
            if use_shell:
                process = subprocess.Popen(
                    command if isinstance(command, str) else " ".join(command),
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    shell=True,
                    cwd=cwd
                )
            else:
                process = subprocess.Popen(
                    command,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    cwd=cwd
                )
            
            stdout, stderr = process.communicate()
            
            if process.returncode != 0:
                raise subprocess.CalledProcessError(process.returncode, command, stdout, stderr)
            
            logging.info(f"Command executed: {command if isinstance(command, str) else ' '.join(command)}")
            logging.debug(f"STDOUT: {stdout.decode('utf-8')}")
            logging.debug(f"STDERR: {stderr.decode('utf-8')}")
            
            return stdout.decode('utf-8'), stderr.decode('utf-8')
        except subprocess.CalledProcessError as e:
            logging.error(f"Error executing command: {command if isinstance(command, str) else ' '.join(command)}")
            logging.error(f"Error message: {str(e)}")
            logging.error(f"STDOUT: {e.stdout.decode('utf-8')}")
            logging.error(f"STDERR: {e.stderr.decode('utf-8')}")
            raise

    def check_program_installed(self, program):
        try:
            self.run_command(['where', program])
            return True
        except subprocess.CalledProcessError:
            return False

    def refresh_environment_variables(self):
        """Refresh the environment variables for the current session."""
        try:
            # Refresh environment variables for the current session
            logging.info("Refreshing environment variables...")
            HWND_BROADCAST = 0xFFFF
            WM_SETTINGCHANGE = 0x001A
            SMTO_ABORTIFHUNG = 0x0002
            result = ctypes.windll.user32.SendMessageTimeoutW(
                HWND_BROADCAST, WM_SETTINGCHANGE, 0, "Environment",
                SMTO_ABORTIFHUNG, 5000, ctypes.byref(ctypes.c_long())
            )
            if result == 0:
                logging.warning("Environment variables refresh timed out.")
            else:
                logging.info("Environment variables refreshed successfully.")
        except Exception as e:
            logging.error(f"Failed to refresh environment variables: {str(e)}")
            logging.error(traceback.format_exc())
            raise

    def install_winget(self):
        try:
            logging.info("Checking if winget is installed...")
            try:
                version_output, _ = self.run_command(['winget', '--version'])
                current_version = version_output.strip()
                if current_version.startswith("v"):
                    current_version = current_version[1:]
                logging.info(f"Current winget version: {current_version}")
                needs_update = packaging.version.parse(current_version) < packaging.version.parse("1.7")
            except FileNotFoundError:
                logging.info("winget is not installed.")
                needs_update = True

            if needs_update:
                logging.info("Installing/Updating winget...")
                with tempfile.TemporaryDirectory() as temp_dir:
                    script_path = os.path.join(temp_dir, "winget-install.ps1")
                    
                    # Download the PowerShell script
                    self.run_command([
                        'powershell',
                        '-Command',
                        f'Invoke-WebRequest -Uri "https://github.com/asheroto/winget-install/releases/latest/download/winget-install.ps1" -OutFile "{script_path}"'
                    ], use_shell=True)
                    
                    # Execute the PowerShell script with -Force parameter and wait for it to finish
                    try:
                        process = subprocess.Popen([
                            'powershell',
                            '-ExecutionPolicy', 'Bypass',
                            '-File', script_path,
                            '-Force'  # Add this to force the update
                        ], stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, creationflags=subprocess.CREATE_NO_WINDOW)
                        
                        # Real-time output processing
                        while True:
                            output = process.stdout.readline()
                            if output == '' and process.poll() is not None:
                                break
                            if output:
                                logging.info(output.strip())
                        
                        # Get the return code
                        return_code = process.poll()
                        
                        # Check for any errors
                        errors = process.stderr.read()
                        if errors:
                            logging.error(f"Errors during winget installation: {errors}")
                        
                        if return_code != 0:
                            raise subprocess.CalledProcessError(return_code, 'PowerShell script')
                        
                        logging.info("Winget installation/update script completed.")
                        
                    except subprocess.CalledProcessError as e:
                        logging.error(f"Failed to execute PowerShell script: {str(e)}")
                        raise

                # Refresh environment variables
                self.refresh_environment_variables()
                
                # Verify installation/update
                try:
                    new_version_output, _ = self.run_command(['winget', '--version'])
                    new_version = new_version_output.strip()
                    if new_version.startswith("v"):
                        new_version = new_version[1:]
                    logging.info(f"Installed/Updated winget version: {new_version}")
                    
                    if packaging.version.parse(new_version) >= packaging.version.parse("1.7"):
                        logging.info("winget has been successfully installed/updated.")
                    else:
                        logging.warning(f"winget version is still below 1.7 after installation/update attempt.")
                        messagebox.showwarning("Update Warning", "winget installation/update may not have succeeded. Please check and update manually if needed.")
                except FileNotFoundError:
                    logging.error("winget still not found after installation attempt.")
                    messagebox.showerror("Error", "Failed to install winget. Please install it manually.")
            else:
                logging.info(f"Existing winget version {current_version} is adequate. No update needed.")

        except Exception as e:
            logging.error(f"An error occurred during winget installation/update: {str(e)}")
            logging.error(traceback.format_exc())
            messagebox.showerror("Error", f"Failed to install/update winget: {str(e)}")
            
    def get_system_architecture(self):
        return 'x64' if sys.maxsize > 2**32 else 'x86'
           
    def get_program_path_from_registry(self, program_name):
        try:
            if program_name == 'git':
                key_path = r"SOFTWARE\GitForWindows"
                value_name = "InstallPath"
            else:
                return None

            with winreg.OpenKey(winreg.HKEY_LOCAL_MACHINE, key_path) as key:
                if value_name:
                    return winreg.QueryValueEx(key, value_name)[0]
                else:
                    return winreg.QueryValueEx(key, "")[0]  # Default value
        except WindowsError:
            return None

    def install_dependencies(self):
        return self.install_calibre()

    def install_calibre(self):
        logging.info("Checking installation for Calibre")
        if not self.check_program_installed('calibre'):
            logging.info("Installing Calibre...")
            try:
                self.run_command(['winget', 'install', '--id', 'calibre.calibre', '-e', '--accept-source-agreements', '--accept-package-agreements'])
                self.refresh_env_in_new_session()
                if self.check_program_installed('calibre'):
                    logging.info("Calibre installed successfully.")
                    return True
                else:
                    logging.warning("Calibre installation not detected after installation attempt.")
                    return False
            except subprocess.CalledProcessError as e:
                logging.error("Failed to install Calibre.")
                logging.error(f"Error output: {e.stderr.decode('utf-8')}")
                return False
        else:
            logging.info("Calibre is already installed.")
            return True
            
    def show_calibre_installation_message(self):
        message = ("Calibre installation failed. Please install Calibre manually.\n"
                   "You can download it from: https://calibre-ebook.com/download_windows")
        messagebox.showwarning("Calibre Installation Required", message)

    def refresh_env_in_new_session(self):
        refresh_cmd = 'powershell -Command "[System.Environment]::GetEnvironmentVariables([System.EnvironmentVariableTarget]::Machine)"'
        output, _ = self.run_command(refresh_cmd, use_shell=True)
        new_env = dict(line.split('=', 1) for line in output.strip().split('\n') if '=' in line)
        os.environ.update(new_env)
        logging.info("Refreshed environment variables in a new session")

    def install_visual_cpp_build_tools(self):
        logging.info("Installing/Updating Microsoft Visual C++ Build Tools...")
        self.update_status("Installing/Updating Microsoft Visual C++ Build Tools...")
        
        # First, accept source agreements
        accept_agreements_command = [
            "winget", "source", "update",
            "--accept-source-agreements"
        ]
        
        try:
            self.run_command(accept_agreements_command)
            logging.info("Source agreements accepted.")
        except subprocess.CalledProcessError as e:
            logging.error(f"Failed to accept source agreements: {e}")
            # Continue with the installation attempt even if this fails
        
        winget_command = [
            "winget", "install", 
            "--id", "Microsoft.VisualStudio.2022.BuildTools",
            "--override", "--quiet --wait --add Microsoft.VisualStudio.Workload.VCTools --includeRecommended",
            "--accept-package-agreements",
            "--accept-source-agreements"
        ]
        
        try:
            process = subprocess.Popen(winget_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True, errors='replace')
            
            output = []
            while True:
                try:
                    line = process.stdout.readline()
                    if not line and process.poll() is not None:
                        break
                    if line:
                        output.append(line.strip())
                        logging.info(line.strip())
                except UnicodeDecodeError as ude:
                    logging.warning(f"UnicodeDecodeError encountered: {ude}")
                    continue
            
            error_output = process.stderr.read().strip()
            if error_output:
                logging.debug(f"STDERR: {error_output}")
            
            returncode = process.poll()
            
            if returncode == 0 or any("No available upgrade found" in line for line in output):
                logging.info("Microsoft Visual C++ Build Tools are up to date or successfully installed.")
                self.update_status("Build Tools are ready.")
                return True
            else:
                logging.error(f"Failed to install/update Microsoft Visual C++ Build Tools. Return code: {returncode}")
                if error_output:
                    logging.error(f"Error output: {error_output}")
                self.update_status("Error during Build Tools installation/update. Check the log for details.")
                return False
            
        except Exception as e:
            logging.error(f"An error occurred during Visual C++ Build Tools installation: {str(e)}")
            logging.error(traceback.format_exc())
            self.update_status("Error during Build Tools installation/update. Check the log for details.")
            return False

    def install_conda(self, install_path):
        logging.info("Installing Miniconda...")
        conda_installer = 'Miniconda3-latest-Windows-x86_64.exe'
        url = f'https://repo.anaconda.com/miniconda/{conda_installer}'
        
        # Download the file
        response = requests.get(url)
        with open(conda_installer, 'wb') as f:
            f.write(response.content)
        
        self.run_command([conda_installer, '/InstallationType=JustMe', '/RegisterPython=0', '/S', f'/D={install_path}'])
        os.remove(conda_installer)

    def check_conda(self, conda_path):
        return os.path.exists(os.path.join(conda_path, 'Scripts', 'conda.exe'))

    def create_conda_env(self, conda_path, env_name, python_version, additional_packages=None):
        logging.info(f"Creating conda environment {env_name}...")
        try:
            # Create the environment with Python
            create_command = [
                os.path.join(conda_path, 'Scripts', 'conda.exe'),
                'create',
                '-n', env_name,
                f'python={python_version}',
                '-y'
            ]
            self.run_command(create_command)

            # If it's the pandrator_installer environment, install ffmpeg from conda-forge
            if env_name == 'pandrator_installer':
                logging.info("Installing ffmpeg from conda-forge for pandrator_installer...")
                ffmpeg_command = [
                    os.path.join(conda_path, 'Scripts', 'conda.exe'),
                    'install',
                    '-n', env_name,
                    'ffmpeg',
                    '-c',
                    'conda-forge',
                    '-y'
                ]
                self.run_command(ffmpeg_command)

            # Install additional packages if specified
            if additional_packages:
                logging.info(f"Installing additional packages: {', '.join(additional_packages)}")
                install_command = [
                    os.path.join(conda_path, 'Scripts', 'conda.exe'),
                    'install',
                    '-n', env_name,
                    '-y'
                ] + additional_packages
                self.run_command(install_command)

        except subprocess.CalledProcessError as e:
            logging.error(f"Failed to create or setup conda environment {env_name}")
            logging.error(f"Error output: {e.stderr.decode('utf-8')}")
            raise

    def install_requirements(self, conda_path, env_name, requirements_file):
        logging.info(f"Installing requirements for {env_name}...")
        self.run_command([os.path.join(conda_path, 'Scripts', 'conda.exe'), 'run', '-n', env_name, 'pip', 'install', '-r', requirements_file])

    def install_package(self, conda_path, env_name, package):
        logging.info(f"Installing {package} in {env_name}...")
        self.run_command([os.path.join(conda_path, 'Scripts', 'conda.exe'), 'run', '-n', env_name, 'pip', 'install', package])

    def download_pretrained_models(self, repo_path):
        pretrained_models_dir = os.path.join(repo_path, 'pretrained_models')
        os.makedirs(pretrained_models_dir, exist_ok=True)
        encodec_url = 'https://huggingface.co/pyp1/VoiceCraft/resolve/main/encodec_4cb2048_giga.th'
        voicecraft_model_dir = os.path.join(pretrained_models_dir, 'VoiceCraft_gigaHalfLibri330M_TTSEnhanced_max16s')
        os.makedirs(voicecraft_model_dir, exist_ok=True)
        
        config_url = 'https://huggingface.co/pyp1/VoiceCraft_gigaHalfLibri330M_TTSEnhanced_max16s/resolve/main/config.json'
        model_url = 'https://huggingface.co/pyp1/VoiceCraft_gigaHalfLibri330M_TTSEnhanced_max16s/resolve/main/model.safetensors'
        encodec_path = os.path.join(pretrained_models_dir, 'encodec_4cb2048_giga.th')
        config_path = os.path.join(voicecraft_model_dir, 'config.json')
        model_path = os.path.join(voicecraft_model_dir, 'model.safetensors')

        def download_file(url, path):
            if not os.path.exists(path):
                logging.info(f"Downloading {os.path.basename(path)}...")
                try:
                    response = requests.get(url, stream=True)
                    response.raise_for_status()
                    with open(path, 'wb') as f:
                        for chunk in response.iter_content(chunk_size=8192):
                            f.write(chunk)
                    logging.info(f"Successfully downloaded {os.path.basename(path)}")
                except requests.RequestException as e:
                    logging.error(f"Failed to download {os.path.basename(path)}")
                    logging.error(f"Error message: {str(e)}")
                    raise
            else:
                logging.info(f"{os.path.basename(path)} already exists. Skipping download.")

        download_file(encodec_url, encodec_path)
        download_file(config_url, config_path)
        download_file(model_url, model_path)

    def install_pytorch_and_xtts_api_server(self, conda_path, env_name):
        logging.info(f"Installing PyTorch and xtts-api-server package in {env_name}...")
        
        try:
            # Install PyTorch
            if self.xtts_cpu_var.get():
                pytorch_cmd = [os.path.join(conda_path, 'Scripts', 'conda.exe'), 'run', '-n', env_name, 'pip', 'install', 'torch==2.1.1', 'torchaudio==2.1.1']
            else:
                pytorch_cmd = [os.path.join(conda_path, 'Scripts', 'conda.exe'), 'run', '-n', env_name, 'pip', 'install', 'torch==2.1.1+cu118', 'torchaudio==2.1.1+cu118', '--extra-index-url', 'https://download.pytorch.org/whl/cu118']
            self.run_command(pytorch_cmd)
            
            # Install xtts-api-server package
            xtts_cmd = [os.path.join(conda_path, 'Scripts', 'conda.exe'), 'run', '-n', env_name, 'pip', 'install', 'xtts-api-server']
            self.run_command(xtts_cmd)
            
            logging.info("PyTorch and xtts-api-server package installed successfully.")
        except subprocess.CalledProcessError as e:
            logging.error("Error installing PyTorch and xtts-api-server package.")
            logging.error(f"Error output: {e.stderr.decode('utf-8')}")
            raise

    def install_audiocraft(self, conda_path, env_name, voicecraft_repo_path):
        logging.info(f"Installing audiocraft package in {env_name}...")
        try:
            audiocraft_repo = 'https://github.com/facebookresearch/audiocraft.git'
            audiocraft_commit = 'c5157b5bf14bf83449c17ea1eeb66c19fb4bc7f0'
            
            # Change to the VoiceCraft repository directory
            os.chdir(voicecraft_repo_path)
            
            # Install audiocraft package
            self.run_command([os.path.join(conda_path, 'Scripts', 'conda.exe'), 'run', '-n', env_name, 'pip', 'install', '-e', f'git+{audiocraft_repo}@{audiocraft_commit}#egg=audiocraft'])
        except subprocess.CalledProcessError as e:
            logging.error(f"Failed to install audiocraft package in {env_name}")
            logging.error(f"Error message: {str(e)}")
            raise

    def install_voicecraft_api_dependencies(self, conda_path, env_name):
        logging.info(f"Installing VoiceCraft API dependencies in {env_name}...")
        try:
            self.run_command([os.path.join(conda_path, 'Scripts', 'conda.exe'), 'run', '-n', env_name, 'conda', 'install', 'pytorch==2.0.1', 'torchvision==0.15.2', 'torchaudio==2.0.2', 'pytorch-cuda=11.7', '-c', 'pytorch', '-c', 'nvidia', '-y'])
            self.run_command([os.path.join(conda_path, 'Scripts', 'conda.exe'), 'run', '-n', env_name, 'conda', 'install', '-c', 'conda-forge', 'montreal-forced-aligner=2.2.17', 'openfst=1.8.2', 'kaldi=5.5.1068', '-y'])
        except subprocess.CalledProcessError as e:
            logging.error(f"Failed to install VoiceCraft API dependencies in {env_name}")
            logging.error(f"Error message: {str(e)}")
            raise

    def download_mfa_models(self, conda_path, env_name):
        logging.info(f"Downloading MFA models in {env_name}...")
        try:
            self.run_command([os.path.join(conda_path, 'Scripts', 'conda.exe'), 'run', '-n', env_name, 'mfa', 'model', 'download', 'dictionary', 'english_us_arpa'])
            self.run_command([os.path.join(conda_path, 'Scripts', 'conda.exe'), 'run', '-n', env_name, 'mfa', 'model', 'download', 'acoustic', 'english_us_arpa'])
        except subprocess.CalledProcessError as e:
            logging.error(f"Failed to download MFA models in {env_name}")
            logging.error(f"Error message: {str(e)}")
            raise

    def replace_files(self, repo_path, file_mappings):
        for src_file, dest_file in file_mappings.items():
            src_path = os.path.join(repo_path, src_file)
            dest_path = os.path.join(repo_path, dest_file)
            try:
                shutil.copy2(src_path, dest_path)
                logging.info(f"Replaced file: {dest_file}")
            except Exception as e:
                logging.error(f"Failed to replace file: {dest_file}")
                logging.error(f"Error message: {str(e)}")
                logging.error(traceback.format_exc())
                raise

    def install_silero_api_server(self, conda_path, env_name):
        logging.info(f"Installing Silero API server in {env_name}...")
        try:
            self.install_package(conda_path, env_name, 'requests')
            self.install_package(conda_path, env_name, 'silero-api-server')
        except subprocess.CalledProcessError as e:
            logging.error(f"Failed to install Silero API server in {env_name}")
            logging.error(f"Error message: {str(e)}")
            raise

    def check_and_update_numpy(self, conda_path, env_name):
        logging.info(f"Checking NumPy version in {env_name}...")
        try:
            # Check current NumPy version
            numpy_version = subprocess.check_output([os.path.join(conda_path, 'Scripts', 'conda.exe'), 'run', '-n', env_name, 'python', '-c', 'import numpy; print(numpy.__version__)'], universal_newlines=True).strip()
            logging.info(f"Current NumPy version: {numpy_version}")
            
            # If NumPy version is 2.x, downgrade to 1.24.3
            if numpy_version.startswith('2.'):
                logging.info("Downgrading NumPy to version 1.24.3...")
                self.run_command([os.path.join(conda_path, 'Scripts', 'conda.exe'), 'run', '-n', env_name, 'pip', 'install', 'numpy==1.24.3'])
                logging.info("NumPy downgraded successfully.")
            else:
                logging.info("NumPy version is compatible. No changes needed.")
        except subprocess.CalledProcessError as e:
            logging.error("Error checking or updating NumPy version.")
            logging.error(f"Error message: {str(e)}")
            raise

    def update_pandrator(self):
        pandrator_base_path = os.path.join(self.initial_working_dir, 'Pandrator')
        pandrator_repo_path = os.path.join(pandrator_base_path, 'Pandrator')
        
        logging.info(f"Checking for Pandrator at: {pandrator_repo_path}")
        
        if not os.path.exists(pandrator_repo_path):
            error_msg = f"Pandrator directory not found at: {pandrator_repo_path}"
            logging.error(error_msg)
            messagebox.showerror("Error", error_msg)
            return

        conda_path = os.path.join(pandrator_base_path, 'conda')
        
        self.update_status("Updating Pandrator...")
        logging.info("Starting Pandrator update process")
        
        try:
            # Git pull
            logging.info(f"Executing git pull in: {pandrator_repo_path}")
            self.pull_repo(pandrator_repo_path)
            
            # Update requirements
            self.update_status("Updating Pandrator dependencies...")
            requirements_file = os.path.join(pandrator_repo_path, 'requirements.txt')
            logging.info(f"Updating requirements from: {requirements_file}")
            
            if not os.path.exists(requirements_file):
                logging.error(f"Requirements file not found at: {requirements_file}")
                raise FileNotFoundError(f"Requirements file not found: {requirements_file}")
            
            update_cmd = [
                os.path.join(conda_path, 'Scripts', 'conda.exe'),
                'run',
                '-n', 'pandrator_installer',
                'pip', 'install', '-r', requirements_file
            ]
            logging.info(f"Executing update command: {' '.join(update_cmd)}")
            self.run_command(update_cmd, cwd=pandrator_repo_path)
            
            msg = "Pandrator has been updated successfully, including its dependencies."
            logging.info(msg)
            messagebox.showinfo("Update", msg)
            
            self.update_status("Pandrator update completed.")
            logging.info("Pandrator update process completed successfully")
        
        except Exception as e:
            error_msg = f"Failed to update Pandrator: {str(e)}"
            logging.error(error_msg)
            logging.error(traceback.format_exc())
            messagebox.showerror("Error", error_msg)
            self.update_status("Pandrator update failed.")

    def clone_repo(self, repo_url, target_dir):
        logging.info(f"Cloning repository {repo_url} to {target_dir}...")
        try:
            porcelain.clone(repo_url, target_dir)
            logging.info("Repository cloned successfully.")
        except Exception as e:
            logging.error(f"Failed to clone repository: {str(e)}")
            raise

    def pull_repo(self, repo_path):
        logging.info(f"Pulling updates for repository at {repo_path}...")
        try:
            repo = porcelain.open_repo(repo_path)
            porcelain.pull(repo)
            logging.info("Repository updated successfully.")
        except Exception as e:
            logging.error(f"Failed to update repository: {str(e)}")
            raise

    def install_rvc_python(self, conda_path, env_name):
        logging.info("Starting RVC Python installation")
        try:
            # Install specific pip version
            logging.info("Installing specific pip version...")
            self.run_command([
                os.path.join(conda_path, 'Scripts', 'conda.exe'),
                'run', '-n', env_name,
                'python', '-m', 'pip', 'install', 'pip==24'
            ])

            # Install RVC Python
            logging.info("Installing RVC Python...")
            self.run_command([
                os.path.join(conda_path, 'Scripts', 'conda.exe'),
                'run', '-n', env_name,
                'pip', 'install', 'rvc-python'
            ])

            # Install specific PyTorch version
            logging.info("Installing specific PyTorch version...")
            self.run_command([
                os.path.join(conda_path, 'Scripts', 'conda.exe'),
                'run', '-n', env_name,
                'pip', 'install', 'torch==2.1.1+cu118', 'torchaudio==2.1.1+cu118',
                '--index-url', 'https://download.pytorch.org/whl/cu118'
            ])

            logging.info("RVC Python installation completed successfully.")

        except Exception as e:
            error_msg = f"An error occurred during RVC Python installation: {str(e)}"
            logging.error(error_msg)
            logging.error(traceback.format_exc())
            raise

    def install_process(self):
        self.disable_buttons()
        pandrator_path = os.path.join(self.initial_working_dir, 'Pandrator')
        conda_path = os.path.join(pandrator_path, 'conda')
        pandrator_already_installed = os.path.exists(pandrator_path)
        
        try:
            self.update_progress(0.1)
            self.update_status("Installing winget...")
            self.install_winget()

            self.update_progress(0.2)
            self.update_status("Installing dependencies...")
            try:
                self.install_dependencies()
            except Exception as e:
                logging.error(f"Error during dependency installation: {str(e)}")
                self.show_calibre_installation_message()

            self.update_progress(0.3)
            self.update_status("Installing Visual C++ Build Tools...")
            self.install_visual_cpp_build_tools()
            
            self.update_progress(0.4)
            self.update_status("Cloning repositories...")
            
            if self.pandrator_var.get() or not pandrator_already_installed:
                self.clone_repo('https://github.com/lukaszliniewicz/Pandrator.git', os.path.join(pandrator_path, 'Pandrator'))
                self.clone_repo('https://github.com/lukaszliniewicz/Subdub.git', os.path.join(pandrator_path, 'Subdub'))

            if self.xtts_var.get() or self.xtts_cpu_var.get():
                self.clone_repo('https://github.com/daswer123/xtts-api-server.git', os.path.join(pandrator_path, 'xtts-api-server'))

            if self.voicecraft_var.get():
                self.clone_repo('https://github.com/lukaszliniewicz/VoiceCraft_API.git', os.path.join(pandrator_path, 'VoiceCraft_API'))

            self.update_progress(0.5)
            self.update_status("Installing Miniconda...")
            if not self.check_conda(conda_path):
                self.install_conda(conda_path)

            if not self.check_conda(conda_path):
                self.update_status("Conda installation failed")
                logging.error("Conda installation failed")
                self.enable_buttons()
                return

            if self.pandrator_var.get() or not pandrator_already_installed:
                self.update_progress(0.6)
                self.update_status("Creating Pandrator Conda environment...")
                self.create_conda_env(conda_path, 'pandrator_installer', '3.10')

                self.update_progress(0.7)
                self.update_status("Installing Pandrator and Subdub requirements...")
                pandrator_repo_path = os.path.join(pandrator_path, 'Pandrator')
                self.install_requirements(conda_path, 'pandrator_installer', os.path.join(pandrator_repo_path, 'requirements.txt'))
                
                subdub_repo_path = os.path.join(pandrator_path, 'Subdub')
                self.install_subdub_requirements(conda_path, 'pandrator_installer', subdub_repo_path)

            if self.xtts_var.get() or self.xtts_cpu_var.get():
                self.update_progress(0.8)
                self.update_status("Creating XTTS Conda environment...")
                self.create_conda_env(conda_path, 'xtts_api_server_installer', '3.10')
                self.update_progress(0.9)
                self.update_status("Installing PyTorch and xtts-api-server...")
                self.install_pytorch_and_xtts_api_server(conda_path, 'xtts_api_server_installer')

            if self.silero_var.get():
                self.update_progress(0.8)
                self.update_status("Creating Silero Conda environment...")
                self.create_conda_env(conda_path, 'silero_api_server_installer', '3.10')

                self.update_progress(0.9)
                self.update_status("Installing Silero API server...")
                self.install_silero_api_server(conda_path, 'silero_api_server_installer')

            if self.voicecraft_var.get():
                self.update_progress(0.8)
                self.update_status("Creating VoiceCraft Conda environment...")
                self.create_conda_env(conda_path, 'voicecraft_api_installer', '3.9.16')

                self.update_progress(0.9)
                self.update_status("Installing VoiceCraft API dependencies...")
                voicecraft_repo_path = os.path.join(pandrator_path, 'VoiceCraft_API')
                self.install_requirements(conda_path, 'voicecraft_api_installer', os.path.join(voicecraft_repo_path, 'requirements.txt'))
                self.install_voicecraft_api_dependencies(conda_path, 'voicecraft_api_installer')
                
                # Install numpy 1.23.5 using conda run pip
                self.update_status("Installing numpy 1.23.5...")
                subprocess.run([conda_path, "run", "-n", "voicecraft_api_installer", "conda", "install", "numpy==1.23.5"], check=True)
                
                self.download_mfa_models(conda_path, 'voicecraft_api_installer')
                self.install_audiocraft(conda_path, 'voicecraft_api_installer', voicecraft_repo_path)

                # Replace files in the VoiceCraft repo
                file_mappings = {
                    'audiocraft_windows/cluster.py': 'src/audiocraft/audiocraft/utils/cluster.py',
                    'audiocraft_windows/environment.py': 'src/audiocraft/audiocraft/environment.py',
                    'audiocraft_windows/checkpoint.py': 'src/audiocraft/audiocraft/utils/checkpoint.py'
                }
                self.replace_files(voicecraft_repo_path, file_mappings)

                # Download pretrained models
                self.download_pretrained_models(voicecraft_repo_path)

            if self.rvc_var.get():
                self.update_progress(0.8)
                self.update_status("Installing RVC Python...")
                self.install_rvc_python(conda_path, 'pandrator_installer')

            if self.whisperx_var.get():
                self.update_progress(0.85)
                self.update_status("Creating WhisperX Conda environment...")
                self.create_conda_env(conda_path, 'whisperx_installer', '3.10')
                self.update_progress(0.90)
                self.update_status("Installing WhisperX...")
                self.install_whisperx(conda_path, 'whisperx_installer')

            # Create or update config file
            config_path = os.path.join(pandrator_path, 'config.json')
            if os.path.exists(config_path):
                with open(config_path, 'r') as f:
                    config = json.load(f)
            else:
                config = {}

            # Update config based on what was installed or already exists
            config['cuda_support'] = config.get('cuda_support', False) or self.xtts_var.get()
            config['xtts_support'] = config.get('xtts_support', False) or self.xtts_var.get() or self.xtts_cpu_var.get()
            config['silero_support'] = config.get('silero_support', False) or self.silero_var.get()
            config['voicecraft_support'] = config.get('voicecraft_support', False) or self.voicecraft_var.get()
            config['whisperx_support'] = config.get('whisperx_support', False) or self.whisperx_var.get()

            with open(config_path, 'w') as f:
                json.dump(config, f)

            self.update_progress(1.0)
            self.update_status("Installation complete!")
            logging.info("Installation completed successfully.")

        except Exception as e:
            logging.error(f"Installation failed: {str(e)}")
            logging.error(traceback.format_exc())
            self.update_status("Installation failed. Check the log for details.")
        finally:
            self.refresh_ui_state()


    def install_subdub_requirements(self, conda_path, env_name, subdub_repo_path):
        logging.info(f"Installing Subdub requirements in {env_name}...")
        try:
            # Clone the Subdub repository if it doesn't exist
            if not os.path.exists(subdub_repo_path):
                self.clone_repo('https://github.com/lukaszliniewicz/Subdub.git', subdub_repo_path)
            
            requirements_file = os.path.join(subdub_repo_path, 'requirements.txt')
            self.install_requirements(conda_path, env_name, requirements_file)
        except subprocess.CalledProcessError as e:
            logging.error(f"Failed to install Subdub requirements in {env_name}")
            logging.error(f"Error message: {str(e)}")
            raise

    def launch_apps(self):
        base_path = os.path.abspath(self.initial_working_dir)
        pandrator_path = os.path.join(base_path, 'Pandrator')
        conda_path = os.path.join(pandrator_path, 'conda')

        self.update_progress(0.3)
        self.update_status("Preparing to launch...")
        logging.info(f"Launch process started. Base directory: {base_path}")
        logging.info(f"Pandrator path: {pandrator_path}")
        logging.info(f"Conda path: {conda_path}")

        pandrator_args = []
        tts_engine_launched = False

        if self.launch_xtts_var.get():
            self.update_progress(0.4)
            self.update_status("Starting XTTS server...")
            xtts_server_path = os.path.join(pandrator_path, 'xtts-api-server')
            logging.info(f"XTTS server path: {xtts_server_path}")
            
            if not os.path.exists(xtts_server_path):
                error_msg = f"XTTS server path not found: {xtts_server_path}"
                self.update_status(error_msg)
                logging.error(error_msg)
                return
            
            try:
                use_cpu = self.xtts_cpu_launch_var.get()
                xtts_process = self.run_xtts_api_server(conda_path, 'xtts_api_server_installer', xtts_server_path, use_cpu)
            except Exception as e:
                error_msg = f"Failed to start XTTS server: {str(e)}"
                self.update_status(error_msg)
                logging.error(error_msg)
                logging.exception("Exception details:")
                return
            
            xtts_server_url = 'http://127.0.0.1:8020/docs'
            if not self.check_xtts_server_online(xtts_server_url):
                error_msg = "XTTS server failed to come online"
                self.update_status(error_msg)
                logging.error(error_msg)
                self.shutdown_xtts()
                return
            
            pandrator_args = ['-connect', '-xtts']
            tts_engine_launched = True

        if self.launch_silero_var.get() and not tts_engine_launched:
            self.update_progress(0.6)
            self.update_status("Starting Silero server...")
            
            try:
                self.silero_process = self.run_silero_api_server(conda_path, 'silero_api_server_installer')
            except Exception as e:
                error_msg = f"Failed to start Silero server: {str(e)}"
                self.update_status(error_msg)
                logging.error(error_msg)
                logging.exception("Exception details:")
                return
            
            silero_server_url = 'http://127.0.0.1:8001/docs'
            if not self.check_silero_server_online(silero_server_url):
                error_msg = "Silero server failed to come online"
                self.update_status(error_msg)
                logging.error(error_msg)
                self.shutdown_silero()
                return
            
            pandrator_args = ['-connect', '-silero']
            tts_engine_launched = True

        if self.launch_voicecraft_var.get() and not tts_engine_launched:
            self.update_progress(0.8)
            self.update_status("Starting VoiceCraft server...")
            voicecraft_repo_path = os.path.join(pandrator_path, 'VoiceCraft_API')
            api_script_path = os.path.join(voicecraft_repo_path, 'api.py')
            
            try:
                self.voicecraft_process = self.run_voicecraft_api_server(conda_path, 'voicecraft_api_installer', api_script_path, voicecraft_repo_path)
            except Exception as e:
                error_msg = f"Failed to start VoiceCraft server: {str(e)}"
                self.update_status(error_msg)
                logging.error(error_msg)
                logging.exception("Exception details:")
                return
            
            voicecraft_server_url = 'http://127.0.0.1:8245/docs'
            if not self.check_voicecraft_server_online(voicecraft_server_url):
                error_msg = "VoiceCraft server failed to come online"
                self.update_status(error_msg)
                logging.error(error_msg)
                self.shutdown_voicecraft()
                return
            
            pandrator_args = ['-connect', '-voicecraft']

        if self.launch_pandrator_var.get():
            self.update_progress(0.9)
            self.update_status("Starting Pandrator...")
            pandrator_script_path = os.path.join(pandrator_path, 'Pandrator', 'pandrator.py')
            logging.info(f"Pandrator script path: {pandrator_script_path}")

            if not os.path.exists(pandrator_script_path):
                error_msg = f"Pandrator script not found: {pandrator_script_path}"
                self.update_status(error_msg)
                logging.error(error_msg)
                return

            try:
                self.pandrator_process = self.run_script(conda_path, 'pandrator_installer', pandrator_script_path, pandrator_args)
            except Exception as e:
                error_msg = f"Failed to start Pandrator: {str(e)}"
                self.update_status(error_msg)
                logging.error(error_msg)
                logging.exception("Exception details:")
                return

        self.update_progress(1.0)
        self.update_status("Apps are running!")
        self.refresh_ui_state()
        self.after(5000, self.check_processes_status)


    def run_script(self, conda_path, env_name, script_path, additional_args=[]):
        logging.info(f"Running script {script_path} in {env_name} with args: {additional_args}")
        
        script_dir = os.path.dirname(script_path)
        
        command = [
            os.path.join(conda_path, 'Scripts', 'conda.exe'),
            'run',
            '-n', env_name,
            'python',
            script_path
        ] + additional_args
        
        process = subprocess.Popen(command, cwd=script_dir, creationflags=subprocess.DETACHED_PROCESS)
        return process

    def run_xtts_api_server(self, conda_path, env_name, xtts_server_path, use_cpu=False):
        logging.info(f"Attempting to run XTTS API server...")
        logging.info(f"Conda path: {conda_path}")
        logging.info(f"Environment name: {env_name}")
        logging.info(f"XTTS server path: {xtts_server_path}")
        logging.info(f"Use CPU: {use_cpu}")

        if not os.path.exists(xtts_server_path):
            raise FileNotFoundError(f"XTTS server path not found: {xtts_server_path}")

        xtts_log_file = os.path.join(xtts_server_path, 'xtts_server.log')

        xtts_server_command = [
            os.path.join(conda_path, 'Scripts', 'conda.exe'),
            'run',
            '-n', env_name,
            'python', '-m', 'xtts_api_server',
        ]

        if use_cpu:
            xtts_server_command.extend(['--device', 'cpu'])
        else:
            if self.lowvram_var.get():
                xtts_server_command.append('--lowvram')
            if self.deepspeed_var.get():
                xtts_server_command.append('--deepspeed')

        logging.info(f"XTTS command: {' '.join(xtts_server_command)}")

        def log_output(pipe, logfile):
            with open(logfile, 'a') as f:
                for line in iter(pipe.readline, b''):
                    decoded_line = line.decode('utf-8').strip()
                    f.write(decoded_line + '\n')
                    f.flush()
                    logging.info(f"XTTS: {decoded_line}")

        try:
            process = subprocess.Popen(xtts_server_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, cwd=xtts_server_path)
            self.xtts_process = process
            
            stdout_thread = threading.Thread(target=log_output, args=(process.stdout, xtts_log_file), daemon=True)
            stderr_thread = threading.Thread(target=log_output, args=(process.stderr, xtts_log_file), daemon=True)
            
            stdout_thread.start()
            stderr_thread.start()

            logging.info(f"XTTS API server process started with PID: {process.pid}")
            return process
        except Exception as e:
            logging.error(f"Failed to start XTTS API server: {str(e)}")
            logging.exception("Exception details:")
            raise

    def check_xtts_server_online(self, url, max_attempts=60, wait_interval=10):
        print("Waiting for xtts server to come online...")
        attempt = 1
        while attempt <= max_attempts:
            try:
                response = requests.get(url)
                if response.status_code == 200:
                    print("xtts server is online.")
                    logging.info("xtts server is online.")
                    return True
            except requests.exceptions.RequestException as e:
                print(f"Attempt {attempt}/{max_attempts}: xtts server is not online yet. Waiting...")
                logging.info(f"xtts server is not online. Waiting... (Attempt {attempt}/{max_attempts})")
            
            time.sleep(wait_interval)
            attempt += 1
        
        logging.error("xtts server failed to come online within the specified attempts.")
        return False

    def run_silero_api_server(self, conda_path, env_name):
        logging.info(f"Running Silero API server in {env_name}...")

        # Create log file for silero server output
        silero_log_file = os.path.join(os.getcwd(), 'silero_server.log')

        # Run silero server command with output redirection
        silero_server_command = f'"{os.path.join(conda_path, "Scripts", "conda.exe")}" run -n {env_name} python -m silero_api_server > "{silero_log_file}" 2>&1'
        process = subprocess.Popen(silero_server_command, shell=True)
        self.silero_process = process
        return process

    def check_silero_server_online(self, url, max_attempts=30, wait_interval=10):
        attempt = 1
        while attempt <= max_attempts:
            try:
                response = requests.get(url)
                if response.status_code == 200:
                    logging.info("Silero server is online.")
                    return True
            except requests.exceptions.RequestException as e:
                logging.info(f"Silero server is not online. Waiting... (Attempt {attempt}/{max_attempts})")
            
            time.sleep(wait_interval)
            attempt += 1
        
        logging.error("Silero server failed to come online within the specified attempts.")
        return False

    def run_voicecraft_api_server(self, conda_path, env_name, api_script_path, voicecraft_repo_path):
        logging.info(f"Running VoiceCraft API server in {env_name}...")
        try:
            # Change to the VoiceCraft repository directory
            os.chdir(voicecraft_repo_path)
            
            voicecraft_server_command = [os.path.join(conda_path, 'Scripts', 'conda.exe'), 'run', '-n', env_name, 'python', api_script_path]
            process = subprocess.Popen(voicecraft_server_command, creationflags=subprocess.CREATE_NEW_CONSOLE)
            self.voicecraft_process = process
            return process
        except Exception as e:
            logging.error(f"Failed to run VoiceCraft API server in {env_name}")
            logging.error(f"Error message: {str(e)}")
            logging.error(traceback.format_exc())
            raise

    def check_voicecraft_server_online(self, url, max_attempts=30, wait_interval=10):
        attempt = 1
        while attempt <= max_attempts:
            try:
                logging.info(f"Checking if VoiceCraft server is online at {url} (Attempt {attempt}/{max_attempts})...")
                response = requests.get(url)
                if response.status_code == 200:
                    logging.info("VoiceCraft server is online.")
                    return True
            except requests.exceptions.RequestException as e:
                logging.warning(f"VoiceCraft server is not online. Waiting... (Attempt {attempt}/{max_attempts})")
            
            time.sleep(wait_interval)
            attempt += 1
        
        logging.error("VoiceCraft server failed to come online within the specified attempts.")
        return False

    def check_processes_status(self):
        if self.pandrator_process and self.pandrator_process.poll() is not None:
            # Pandrator has exited
            self.pandrator_process = None
            self.shutdown_apps()  # Shut down other apps when Pandrator exits
        if self.xtts_process and self.xtts_process.poll() is not None:
            # XTTS has exited
            self.xtts_process = None
        if self.silero_process and self.silero_process.poll() is not None:
            # Silero has exited
            self.silero_process = None
        if self.voicecraft_process and self.voicecraft_process.poll() is not None:
            # VoiceCraft has exited
            self.voicecraft_process = None
        
        if not self.pandrator_process and not self.xtts_process and not self.silero_process and not self.voicecraft_process:
            self.update_status("All processes have exited.")
            self.refresh_ui_state()
        else:
            self.after(5000, self.check_processes_status)  # Schedule next check

    def shutdown_apps(self):
        self.shutdown_xtts()
        self.shutdown_silero()
        self.shutdown_voicecraft()

    def shutdown_xtts(self):
        if self.xtts_process:
            logging.info(f"Terminating XTTS process with PID: {self.xtts_process.pid}")
            try:
                parent = psutil.Process(self.xtts_process.pid)
                for child in parent.children(recursive=True):
                    try:
                        child.terminate()
                    except psutil.AccessDenied:
                        logging.warning(f"Access denied when terminating child process with PID: {child.pid}")
                parent.terminate()
                self.xtts_process.wait(timeout=10)
            except psutil.NoSuchProcess:
                logging.info("XTTS process already terminated.")
            except psutil.TimeoutExpired:
                logging.warning("XTTS process did not terminate, forcing kill")
                parent = psutil.Process(self.xtts_process.pid)
                for child in parent.children(recursive=True):
                    try:
                        child.kill()
                    except psutil.AccessDenied:
                        logging.warning(f"Access denied when killing child process with PID: {child.pid}")
                parent.kill()
            self.xtts_process = None

        # Check if any process is using port 8020 and kill it
        for conn in psutil.net_connections():
            if conn.laddr.port == 8020:
                try:
                    process = psutil.Process(conn.pid)
                    if process.pid != 0:  # Skip System Idle Process
                        process.terminate()
                        logging.info(f"Terminated process using port 8020: PID {conn.pid}")
                except psutil.NoSuchProcess:
                    logging.info(f"Process using port 8020 (PID {conn.pid}) no longer exists")
                except psutil.AccessDenied:
                    logging.warning(f"Access denied when terminating process with PID: {conn.pid}")

    def shutdown_silero(self):
        if self.silero_process:
            logging.info(f"Terminating Silero process with PID: {self.silero_process.pid}")
            try:
                parent = psutil.Process(self.silero_process.pid)
                for child in parent.children(recursive=True):
                    try:
                        child.terminate()
                    except psutil.AccessDenied:
                        logging.warning(f"Access denied when terminating child process with PID: {child.pid}")
                parent.terminate()
                self.silero_process.wait(timeout=10)
            except psutil.NoSuchProcess:
                logging.info("Silero process already terminated.")
            except psutil.TimeoutExpired:
                logging.warning("Silero process did not terminate, forcing kill")
                parent = psutil.Process(self.silero_process.pid)
                for child in parent.children(recursive=True):
                    try:
                        child.kill()
                    except psutil.AccessDenied:
                        logging.warning(f"Access denied when killing child process with PID: {child.pid}")
                parent.kill()
            self.silero_process = None

        # Check if any process is using port 8001 and kill it
        for conn in psutil.net_connections():
            if conn.laddr.port == 8001:
                try:
                    process = psutil.Process(conn.pid)
                    if process.pid != 0:  # Skip System Idle Process
                        process.terminate()
                        logging.info(f"Terminated process using port 8001: PID {conn.pid}")
                except psutil.NoSuchProcess:
                    logging.info(f"Process using port 8001 (PID {conn.pid}) no longer exists")
                except psutil.AccessDenied:
                    logging.warning(f"Access denied when terminating process with PID: {conn.pid}")

    def shutdown_voicecraft(self):
        if self.voicecraft_process:
            logging.info(f"Terminating VoiceCraft process with PID: {self.voicecraft_process.pid}")
            try:
                parent = psutil.Process(self.voicecraft_process.pid)
                for child in parent.children(recursive=True):
                    try:
                        child.terminate()
                    except psutil.AccessDenied:
                        logging.warning(f"Access denied when terminating child process with PID: {child.pid}")
                parent.terminate()
                self.voicecraft_process.wait(timeout=10)
            except psutil.NoSuchProcess:
                logging.info("VoiceCraft process already terminated.")
            except psutil.TimeoutExpired:
                logging.warning("VoiceCraft process did not terminate, forcing kill")
                parent = psutil.Process(self.voicecraft_process.pid)
                for child in parent.children(recursive=True):
                    try:
                        child.kill()
                    except psutil.AccessDenied:
                        logging.warning(f"Access denied when killing child process with PID: {child.pid}")
                parent.kill()
            self.voicecraft_process = None

        # Check if any process is using port 8245 and kill it
        for conn in psutil.net_connections():
            if conn.laddr.port == 8245:
                try:
                    process = psutil.Process(conn.pid)
                    if process.pid != 0:  # Skip System Idle Process
                        process.terminate()
                        logging.info(f"Terminated process using port 8245: PID {conn.pid}")
                except psutil.NoSuchProcess:
                    logging.info(f"Process using port 8245 (PID {conn.pid}) no longer exists")
                except psutil.AccessDenied:
                    logging.warning(f"Access denied when terminating process with PID: {conn.pid}")

    def destroy(self):
        self.shutdown_apps()
        super().destroy()

if __name__ == "__main__":
    app = PandratorInstaller()
    app.mainloop()


--requirements.txt--

customtkinter
requests
pydub
unidecode
sentence-splitter
pygame
CTkMessagebox
CTkToolTip
pysrt
num2words
ffmpeg-python
pdftextract
py-hasami
nltk


---tts_voices/---


---tts_voices\VoiceCraft/---


--sample_male_16k.txt--

at his disposal, and he used it, he coerced them with kindness. Oh, it would have destroyed the country, it would have gone up in flames. It would have been, the Congo, it would have been

--tmp.txt--


